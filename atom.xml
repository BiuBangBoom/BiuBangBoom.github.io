<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://biubangboom.github.io/</id>
    <title>Gridea</title>
    <updated>2020-12-03T02:21:37.987Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://biubangboom.github.io/"/>
    <link rel="self" href="https://biubangboom.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://biubangboom.github.io/images/avatar.png</logo>
    <icon>https://biubangboom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Spring MVC Handler参数封装]]></title>
        <id>https://biubangboom.github.io/post/spring-mvc-handler-can-shu-feng-zhuang/</id>
        <link href="https://biubangboom.github.io/post/spring-mvc-handler-can-shu-feng-zhuang/">
        </link>
        <updated>2020-12-02T05:11:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="入口">入口</h1>
<p>后续（2020年12月03日10:19:06）：整理资料发现对DataBinder，WebDataBinder的认识出现了错误，所以原文中关于DataBinder的介绍许多都是错的，但仍可借此关注SpringMVC入参流程。<br>
DataBinder的源码文章：https://blog.csdn.net/f641385712/article/details/90702928</p>
<hr>
<p>今早看在mica的xss封装。</p>
<p>发现用到了一个叫<code>InitBinder</code>的注解。发现自己的能力还差很多阿。</p>
<hr>
<p>先记录一下涉及的知识点。</p>
<p><code>ControllerAdvice</code>，<code>PropertyEditor</code>，<code>PropertyEditorSupport</code>，<code>PropertyManager</code>，<code>WebDataBinder</code></p>
<p>比较关心的是通过<code>@InitBinder</code>注册进<code>WebDataBinder</code>的<code>StringPropertiesEditor</code>什么时候会执行。</p>
<p>结论：<code>WebDataBinder</code>其实可以理解为是KV等类型的一个处理流程，通过<code>AbstractNameValueArugmentSolver</code>的<code>ArguemntSolver</code>调用，所以没有脱离ArgumentSolver的范围，并且继承自该抽象类的方法都会调用对应的WebDataBinder。<br>
后记：：<code>AbstractNameValueArugmentSolver</code>为子类预留了<code>handleResolvedValue</code>方法拓展。</p>
<p>另外，MVC关于DataBinder的传参等依旧是很复杂（<code>WebDataBinderFactory</code>）的。</p>
<p>WebDataBinder的调用则是通过调用<code>PropertyEditor</code>实现。（PropertyEditorSupport为子类，实现了<code>PropertyEditor</code>接口大部分了方法。）</p>
<pre><code class="language-java">// editor为在WebDataBinder中registCustom的自定义编辑器。
convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);
</code></pre>
<blockquote>
<pre><code class="language-java">// 类信息
public class DataBinder implements PropertyEditorRegistry, TypeConverter
</code></pre>
</blockquote>
<p>之前没有做出过使用。</p>
<p><code>DataBinder</code>通过与ControllerAdvice配合使用。</p>
<blockquote>
<p>关于ControllerAdcice的介绍</p>
<p>Specialization of {@link Component @Component} for classes that declare{@link ExceptionHandler @ExceptionHandler}, {@link InitBinder @InitBinder}, or{@link ModelAttribute @ModelAttribute} methods to be shared across multiple {@code @Controller} classes.</p>
<p>简意：一个Component的特殊类，可用于声明（定义方法）<code>@ExceptionHandler</code>，<code>@InitBinder</code>，@<code>ModelAttribute</code>。<br>
method被多个Controller类共享（Controller全局）。</p>
<p>关于@ModelAttribute还不清楚作用。</p>
</blockquote>
<p><code>ControllerAdvice</code>的<code>InitBinder</code>即是本次的入口。</p>
<blockquote>
<p>关于InitBinder的介绍</p>
<p>Annotation that identifies methods which initialize the {@link org.springframework.web.bind.WebDataBinder} which will be used for populating command and form object arguments of annotated handler methods.</p>
<p>简意：注解会通过<code>WebDataBinder</code>进行初始化。用于填充接口的command和form类型参数。</p>
<p>typical arguments are {@link org.springframework.web.bind.WebDataBinder} in combination with {@link org.springframework.web.context.request.WebRequest} or {@link java.util.Locale}, allowing to register context-specific editors.</p>
<p>简意：@InitBinder注解作用在方法上，方法可传入参数WebDataBinder，WebRequest，Locale辅助使用。<br>
其中<code>WebDataBinder</code>是关键，可用于实现DataBinder的注册。</p>
</blockquote>
<hr>
<h1 id="参数封装流程">参数封装流程</h1>
<p>这是之前为了追踪，如何将请求的参数（form、path variable，requestBody等）封装成对应的类型的属性或对象而进行的追踪，但当时没有完成，也缺少了<code>DataBind</code>这部分的数据处理。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9eq3m6iqj317t044q3e.jpg" alt="image-20200323024355131" loading="lazy"></figure>
<p>在HandlerAdapter.Handle()方法中，对request的param进行成handler所需的对象。（这一行方法其实执行了很多，只是最后得到了model and view罢了，中间蛮多过程且不太好追踪。）</p>
<p>其实基本的入口是没有找错的：<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code></p>
<p><code>InvocableHandlerMethod</code>方法参数封装入口<br>
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9eq569m3j31fh0u0doq.jpg" alt="image-20200323024802095" loading="lazy"></p>
<p>解析逻辑</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9fj3fmmfj31270ebtc2.jpg" alt="image-20201202130632894" loading="lazy"></figure>
<p>获取解析器的逻辑：<code>HandlerMethodArgumentResolverComposite</code><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9eq490mkj31en0o6q99.jpg" alt="image-20200323023101703" loading="lazy"><br>
该类中含有<code>List&lt;HandlerMethodArgumentResolver&gt;</code>，包含了所有的参数解析器。<br>
在方法<code>getArgumentResolver</code>下，对每个参数调用正确的参数解析器进行解析。</p>
<p>其中包括<code>RequestAttributeMethodArgumentResolver</code> <code>RequestParamMethodArgumentResolver</code> <code>RequestParamMapMethodArgumentResolver</code> <code>ServletModelAttributeMethodProcessor</code> <code>RequestResponseBodyMethodProcessor</code><br>
（RequestParam、RequestParamMap、ModelAttributeMethod、RequestBody）</p>
<p>其他的都比较好理解，比较特殊的是**<code>ServletModelAttributeMethodProcessor</code>**，如果不带任何的注解、或是参数类型是简单类型，则会匹配上该方法，可以理解为是默认的。</p>
<pre><code class="language-java">@Override
	public boolean supportsParameter(MethodParameter parameter) {
		return (parameter.hasParameterAnnotation(ModelAttribute.class) ||
				(this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));
	}
</code></pre>
<p>同理，如果对象不带任何的注解=@ModelAttribute。（不同于@RequestAttribute）。</p>
<p>同时发现可以使用<code>Map&lt;String,String&gt;</code>可以封装上所有的RequestParam，默认实现了。</p>
<h1 id="总结">总结</h1>
<p>竟然误解了。</p>
<p>一直想追踪这个DataBinder与ArgumentResolver的执行顺序。</p>
<p>但其实不是这样的。</p>
<p>DataBinder的执行是在一个抽象类：<code>AbstractNamedValueMethodArgumentResolver</code>中，是其他的ArgumentResolver（kv类型等）的抽象类。</p>
<blockquote>
<p>抽象类的介绍：</p>
<p>Abstract base class for resolving method arguments from a named value. Request parameters, request headers, and path variables are examples of named values. Each may have a name, a required flag, and a default value.</p>
<p>简介：</p>
<p>这个抽象类可以帮助方法解决一些kv类型的请求参数、请求头信息或者路径变量。</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9f7snlovj311d0djn1r.jpg" alt="image-20201202125610629" loading="lazy"></figure>
<p>由该抽象类定义的方法（resolveArgument）实现对DataBinder的调用，同时预留<code>handleResolvedValue</code>方法交由实现类拓展。</p>
<h1 id="资料">资料</h1>
<p>https://blog.csdn.net/f641385712/article/details/90702928</p>
<p>补充关于mica xss-common的设置（文章入口来源）：</p>
<pre><code class="language-java">@ControllerAdvice
public class FormXssClean {

	@InitBinder
	public void initBinder(WebDataBinder binder) {
		// 处理前端传来的表单字符串
		binder.registerCustomEditor(String.class, new StringPropertiesEditor());
	}

	@Slf4j
	public static class StringPropertiesEditor extends PropertyEditorSupport {

		@Override
		public String getAsText() {
			Object value = getValue();
			return value != null ? value.toString() : StrUtil.EMPTY;
		}

		@Override
		public void setAsText(String text) throws IllegalArgumentException {
			if (text == null) {
				setValue(null);
			}
			else if (XssHolder.isEnabled()) {
				String value = XssUtil.clean(text);
				setValue(value);
				log.trace(&quot;Request parameter value:{} cleaned up by mica-xss, current value is:{}.&quot;, text, value);
			}
			else {
				setValue(text);
			}
		}

	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatis-IOC追踪]]></title>
        <id>https://biubangboom.github.io/post/mybatis-ioc-zhui-zong/</id>
        <link href="https://biubangboom.github.io/post/mybatis-ioc-zhui-zong/">
        </link>
        <updated>2020-11-18T15:52:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="官方文档入口">官方文档入口</h1>
<p>Spring-Mybatis：https://mybatis.org/spring/zh/getting-started.html</p>
<h1 id="基于注解与ioc实现mybatis的源码分析">基于注解与IOC实现Mybatis的源码分析</h1>
<h2 id="基于注解启动spring-mybatis流程追踪">基于注解启动Spring-Mybatis流程追踪</h2>
<h3 id="mapperscanners作为入口">@MapperScanners作为入口</h3>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkt5vd5kwej30op07njsa.jpg" alt="image-20201118112342843" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkt5voezjqj30wb02gt8x.jpg" alt="image-20201118112405695" loading="lazy"></figure>
<hr>
<p>对于每个MapperScanner执行<code>void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry)</code>方法。</p>
<pre><code class="language-java">ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkt6929n16j30j10mkq58.jpg" alt="image-20201118113657384" loading="lazy"></figure>
<pre><code class="language-java">// annotations是MapperScanners注解类。
for (int i = 0; i &lt; annotations.length; i++) {
  registerBeanDefinitions(importingClassMetadata, annotations[i], registry,
      generateBaseBeanName(importingClassMetadata, i));
}
</code></pre>
<pre><code class="language-java">// foreach执行`registerBeanDefinitions`方法
// registerBeanDefinitions抽离
BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
// **MapperScannerConfigurer**
// 读取MapperScanner中的annoMeta(注解信息)封装进builder（MapperScannerConfigurer BeanDefinitionBuilder）中。

传入的信息也比较关键，这个MapperScannerConfigurer类似于@Mapper扫包配置类，所以里面包括了说需要扫描@Mapper注解，需要扫描的路径basePackage等信息。
</code></pre>
<p>（AutoConfiguredMapperScannerRegistrar中自动配置的MapperScannerConfigurer情况）</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkte72i8zrj311l0dn789.jpg" alt="image-20201118161150003" loading="lazy"></figure>
<p>这个MapperScannerConfigurer是个<strong>BeanDefinitionRegistryPostProcessor</strong>类 ----&gt; <code>postProcessBeanDefinitionRegistry()</code></p>
<pre><code class="language-java">public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
		// 应该就是扫包器了，扫描@MapperScan(basePage=“”),extends ClassPathBeanDefinitionScanner..
		ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
 		scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage,ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));   
}
</code></pre>
<pre><code class="language-java">public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner
</code></pre>
<p>启动@Mapper扫描</p>
<figure data-type="image" tabindex="5"><img src="../../Library/Application%20Support/typora-user-images/image-20201118161515175.png" alt="image-20201118161515175" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gktekfrlrzj311n0e6ad0.jpg" alt="image-20201118162431588" loading="lazy"></figure>
<p>这个就是关键的实现@Mapper自动注入功能的流程了。</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gktep5381oj30we0u0qf2.jpg" alt="image-20201118162911933" loading="lazy"></figure>
<pre><code class="language-java">      // the mapper interface is the original class of the bean.but, the actual class of the bean is MapperFactoryBean
      // 设置(MapperBeanFactory)构造器的参数
      definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59
			// 关键内容设置 ---&gt; MapperFactoryBean.class
      definition.setBeanClass(this.mapperFactoryBeanClass);

			// 设置sqlSessionFactory
			
			// 设置sqlTemplateFactory

			// definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
</code></pre>
<p>所以上述是流程的追踪，下面是动态代理类（MapperFactoryBean）如何实现动态代理。</p>
<h2 id="功能实现的核心">功能实现的核心</h2>
<h3 id="mapperfactorybean"><strong>MapperFactoryBean</strong></h3>
<pre><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt;
</code></pre>
<pre><code class="language-java">// SqlSessionDaoSupport &lt;-- DaoSupport 中抽象出来的方法。
// 与SpringJDBC应该有不少的关系，需要继续学习这部分。
protected void checkDaoConfig(){
 Configuration configuration = getSqlSession().getConfiguration();
 // 但这里解决了一个困惑点。
 // 正常Mybatis的DefaultSessionFactory获取Mapper对象，其实都是通过configuration获取，流程看下代码框。
 configuration.addMapper(this.mapperInterface);
}

---
 // Configuration
   public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
   mapperRegistry.addMapper(type);
 }
</code></pre>
<pre><code class="language-java">	@Override
  public T getObject() throws Exception { // FactoryBean的方法。
    // getSqlSession()--&gt;DefaultSqlSession
    // this.mapperInterfact，接口类。
    return getSqlSession().getMapper(this.mapperInterface);
  }

	---
    // DefaultSqlSession
    @Override
  	public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
    	// 会通过配置文件获取，与原版Mybatis逻辑相同。
    	// 这里的原因其实有在「checkDaoConfig」中，通过addMapper加载进Configuration。
    	return configuration.getMapper(type, this);
	  }
  
</code></pre>
<pre><code class="language-java">	// MapperRegistrar 动态代理实现了就是。
	@SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
    }
    try {
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
    }
  }
</code></pre>
<hr>
<h1 id="基于spring-bootmybatis-spring-boot-starter的自动装配流程">基于Spring Boot(mybatis-spring-boot-starter)的自动装配流程</h1>
<pre><code class="language-xml">				&lt;!--spring framework version :: 2.4.0--&gt;
				&lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.4&lt;/version&gt;
        &lt;/dependency&gt;
-----------
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
  &lt;/dependencies&gt;
</code></pre>
<p>这边解析一下新增加的<code>mybatis-spring-boot-autoconfigure</code></p>
<pre><code class="language-properties"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
</code></pre>
<p><code>MybatisAutoConfiguration</code></p>
<pre><code class="language-java">/**
 * {@link EnableAutoConfiguration Auto-Configuration} for Mybatis. Contributes a {@link SqlSessionFactory} and a
 * {@link SqlSessionTemplate}.
 *
 * If {@link org.mybatis.spring.annotation.MapperScan} is used, or a configuration file is specified as a property,
 * those will be considered, otherwise this auto-configuration will attempt to register mappers based on the interface
 * definitions in or under the root auto-configuration package.
 *
 * @author Eddú Meléndez
 * @author Josh Long
 * @author Kazuki Shimizu
 * @author Eduardo Macarrón
 */


// 简化：为应用程序构造SqlSessionFactory，SqlTemplate。
// 如果有使用MapperScan注册则注解将会起作用。
// otherwise,这个autoCOnfiguration会尝试去注册在root auto-configuration package下的基于接口定义。 ？？？
</code></pre>
<pre><code class="language-java">@org.springframework.context.annotation.Configuration
@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })
@ConditionalOnSingleCandidate(DataSource.class)
@EnableConfigurationProperties(MybatisProperties.class)
@AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })
</code></pre>
<p><code>MybatisAutoConfiguration</code>构造器</p>
<pre><code class="language-java">MybatisProperties
interceptorsProvider
typeHandlersProvider
languageDriversProvider
resourceLoader
databaseIdProvider
configurationCustomizersProvider
  
# MybatisProperties 读取配置文件（application.properties）后封装的对象数据
这个配置文件还挺多内容选项的。包括传统的xml配置文件路径，mapperLocation，typeAliasesPackage，typeAliasesSuperType等等，可理解为传统的mybatis configuration配置文件转移到了spring boot配置文件中。
  
  
# interceptorsProvider 这个蛮重要的，对于Mybatis的拓展。目前不太明白是如何填装进去的。
  
----其余的先先省略。继续追踪启动流程。
</code></pre>
<p>之后的MybatisAutoConfiguration流程就简单很多的，检查是否有配置配置文件（xml等），如果有并且（check）则进行加载。</p>
<p>接着就就是填装SqlSessionFactoryBean SqlTemplate。</p>
<p><strong>同时这个MybatisAutoConfiguration类中，竟然有内部类..</strong></p>
<p><code>MapperScannerRegistrarNotFoundConfiguration</code></p>
<pre><code class="language-java">/**
   * If mapper registering configuration or mapper scanning configuration not present, this configuration allow to scan
   * mappers based on the same component-scanning path as Spring Boot itself.
   */
  @org.springframework.context.annotation.Configuration
  @Import(AutoConfiguredMapperScannerRegistrar.class)
  @ConditionalOnMissingBean({ MapperFactoryBean.class, MapperScannerConfigurer.class })
public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean 
</code></pre>
<p>Import的这个<code>AutoConfiguredMapperScannerRegistrar</code>这个就比较关键了。</p>
<p>用于注册<code>MapperScannerConfigurer</code>进BeanFactory。</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gktdtbswgoj312z0n8gs7.jpg" alt="image-20201118155835237" loading="lazy"></figure>
<p>这就回到了Spring-Mybatis中（基于MapperScannerConfigurer实现）。</p>
<p><strong>总结：所以这个Mybatis starter关键有三步。</strong></p>
<ol>
<li>
<p>读取application-properotes（MybatisProperties类），将过往的基于xml的配置文件生成Configuration方式替换掉。</p>
<p>这一步骤通过注解与构造器实现，完成后还会对配置文件中的数据进行一个校验（<code>afterPropertiesSet</code>），例如配置了configurationLocation等。</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)
// 这里就已经包含了Mybatis的Configuration类，没错，就是Mybatis中的那个比较关键的类。
public class MybatisProperties 

//但在基于SpringBoot或是注解的情况下，这个原本挺重要的Configuration类似乎又不那么重要，甚至只在特殊的情况下，例如custom 		config的情况下发挥作用。
  
  /**
   * A Configuration object for customize default settings. If {@link #configLocation} is specified, this 		 * property is
   * not used.
   */

  
</code></pre>
</li>
<li>
<p>基于@Bean注解，生成SqlSessionFactory，SqlTemplate。</p>
<pre><code class="language-java">@Bean
@ConditionalOnMissingBean
public void method(){}
</code></pre>
</li>
<li>
<p>引入<code>AutoConfiguredMapperScannerRegistrar</code>类，引入方式其实与@Bean相同，只不过通过了内部类实现。</p>
<pre><code class="language-java">@org.springframework.context.annotation.Configuration
@Import(AutoConfiguredMapperScannerRegistrar.class)
@ConditionalOnMissingBean({ MapperFactoryBean.class, MapperScannerConfigurer.class }
public static class MapperScannerRegistrarNotFoundConfiguration{}
</code></pre>
</li>
<li>
<p>Import并执行<code>AutoConfiguredMapperScannerRegistrar</code>类，通过MybatisProperties信息，构造<code>MapperScanConfigurer</code>，并放入BeanFactory。</p>
</li>
</ol>
<p>往下的流程就是执行<code>MapperScanConfigurer</code>的过程。这过程与Spring-Mybatis一致，意思是至此，mybatis-spring-boot-starter的工作基本实现。</p>
<hr>
<h1 id="容易混淆的记录点">容易混淆的记录点</h1>
<ul>
<li>Import</li>
<li>ImportSelector</li>
<li>Configuration</li>
<li>ImportBeanDefinitionRegistrar</li>
<li>BeanDefinitionPostProcessor</li>
</ul>
<p><code>MapperScannerConfigurer</code>??</p>
]]></content>
    </entry>
</feed>