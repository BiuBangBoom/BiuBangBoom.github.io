<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://biubangboom.github.io/</id>
    <title>Deladelappp</title>
    <updated>2021-02-20T19:12:31.481Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://biubangboom.github.io/"/>
    <link rel="self" href="https://biubangboom.github.io/atom.xml"/>
    <logo>https://biubangboom.github.io/images/avatar.png</logo>
    <icon>https://biubangboom.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Deladelappp</rights>
    <entry>
        <title type="html"><![CDATA[Netty Future实现Listener回调功能]]></title>
        <id>https://biubangboom.github.io/post/netty-future-shi-xian-listener-hui-diao-gong-neng/</id>
        <link href="https://biubangboom.github.io/post/netty-future-shi-xian-listener-hui-diao-gong-neng/">
        </link>
        <updated>2021-02-20T19:12:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
        final ExecutorService executor = Executors.newFixedThreadPool(1);
        EventExecutor eventExecutor = new DefaultEventExecutor(executor);

        final Future&lt;String&gt; futureResult = eventExecutor.submit(new Callable&lt;String&gt;() {
            @Override
            public String call() throws Exception {
                return &quot;hello world&quot;;
            }
        });
        futureResult.addListener(future -&gt; {
            if(future.isSuccess()){
                System.out.println(&quot;future get::&quot; + future.get());
            } else if(future.isCancelled()) {
                System.out.println(&quot;task cancelled&quot;);
            } else if(future.cause() != null){
                System.out.println(&quot;exception catch..&quot; + future.cause().getMessage());
            }
        });
    }
</code></pre>
<p>想知道Netty是如何实现任务完成后，回调Listener的。</p>
<hr>
<h1 id="将任务包装并添加进队列">将任务包装并添加进队列。</h1>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnulihzealj30vo0jsq6a.jpg" alt="image-20210221001910915" loading="lazy"></figure>
<h1 id="获取队列中的任务并执行">获取队列中的任务并执行</h1>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnulilcvc8j315u0p0jxr.jpg" alt="image-20210221004237462" loading="lazy"></figure>
<h1 id="关键">关键</h1>
<p>自定义的任务在submit的时候被包装过，包装成了<code>PromiseTask</code>。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnulioh85hj30mp09lgmg.jpg" alt="image-20210221004453444" loading="lazy"></figure>
<p>所以在任务进行run的时候，执行的是被包装过的PromiseTask的run()，除了执行本身的任务外，还将调用<code>setSuccessInternal(Future future)</code>方法进行通知Listener。</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnulir86vkj30wj092jsw.jpg" alt="image-20210221004817186" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[围绕Thread的一些易混淆类]]></title>
        <id>https://biubangboom.github.io/post/wei-rao-thread-de-yi-xie-yi-hun-yao-lei/</id>
        <link href="https://biubangboom.github.io/post/wei-rao-thread-de-yi-xie-yi-hun-yao-lei/">
        </link>
        <updated>2021-02-05T06:16:05.000Z</updated>
        <content type="html"><![CDATA[<p>关于线程相关容易混淆的概念</p>
<p>遇到了一系列关于线程的名词，说不清楚。</p>
<ul>
<li>Thread</li>
<li>ThreadGroup</li>
<li>ThreadFactory</li>
<li>DefaultThreadFactory</li>
<li>Executor</li>
<li>ExecutorService</li>
<li>Executors</li>
<li>ThreadPoolExecutor</li>
</ul>
<h1 id="thread">Thread</h1>
<p>这个就是线程，没有什么要说太多的？</p>
<h1 id="threadgroup">ThreadGroup</h1>
<p>线程所在的组。</p>
<p>其实每个线程都有所属的ThreadGroup，用于管理线程/线程管理。</p>
<p>即便是直接<code>new Thread(()-&gt;{}).start()</code>的线程，也会有归属的ThreadGroup。<br>
也可在<code>new Thread(ThreadGroup group)</code>手动传入线程组。</p>
<p>同时发现，线程组也有层级结构。</p>
<h1 id="threadfactory">ThreadFactory</h1>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncmshf5s7j30l90ccwfw.jpg" alt="image-20210205135155023" loading="lazy"></figure>
<p>为接口，功能为创建线程。</p>
<h2 id="defaultthreadfactory">DefaultThreadFactory</h2>
<p>ThreadFactory常用的默认实现类。</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncmsld173j31350hv0v7.jpg" alt="image-20210205135352707" loading="lazy"></figure>
<p>与直接<code>new Thread()</code>的差别是什么呢..</p>
<p>其实没有发现太大的差别，可能是创建的时候传入了一些统一的线程参数以及信息。</p>
<blockquote>
<p>整个线程工厂产生的线程具有相同的group、namePrefix.</p>
<p>from csdn。</p>
</blockquote>
<p>java.nio以及io.netty中都有这个DefaultThreadFactory类，主要作用似乎都是绑定namePrefix。（新建线程的名字前缀）<br>
其中io.netty中的DefaultThreadFactory更加强大，添加了对匿名内部类的支持。</p>
<h1 id="executor">Executor</h1>
<p>执行器，也是一个简单的接口而已。</p>
<p>所以只是一个接口罢了，但通过接口可大概猜测内部实现维护了一个线程池（集合），用于执行(execute)传入的任务。</p>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncmsp03f9j30v00dc0uv.jpg" alt="image-20210205135445044" loading="lazy"></figure>
<h2 id="executorservice-extend-executor">ExecutorService extend Executor</h2>
<p>拓展了一些方法，例如<code>shutdown</code>，<code>isTerminated</code>，还有拓展异步执行<code>submit(Runnable task)</code>。</p>
<p>常见的实现类：<code>ThreadPoolExecutor。</code></p>
<h1 id="executors">Executors</h1>
<p>这个用的其实还比较多，有点类似于线程池的功能，之前其实也学习过。</p>
<p>内部提供了一些静态方法，用于创建默认的线程池，但这个线程池返回的对象就很有意思了，</p>
<p>是<code>ExecutorService</code>，没错，正是上方的任务执行器。</p>
<p>而这个类的实现就是<code>ThreadPoolExecutor</code></p>
<h1 id="threadpoolexecutor">ThreadPoolExecutor</h1>
<p>这是一个新的名字，之前似乎没有看到过。</p>
<p><strong>但这个其实就是调用Exectors返回的ExecutorService的默认实现类。</strong></p>
<p>也就是说<code>ThreadPoolExecutor extend ExecutorService</code>，用于任务执行与调用。<br>
（但其实中间还有一层AbstractThreadPoolExecutor，似乎没有做功能的拓展，而是提供了一定的方法默认实现与流程，没有细究。）</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncmsrtee8j30gs0bh0tq.jpg" alt="image-20210205140338499" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ObjectFactory-BeanFactory-FactoryBean]]></title>
        <id>https://biubangboom.github.io/post/objectfactory-beanfactory-factorybean/</id>
        <link href="https://biubangboom.github.io/post/objectfactory-beanfactory-factorybean/">
        </link>
        <updated>2020-12-04T04:39:13.000Z</updated>
        <content type="html"><![CDATA[<p>推荐参考资料：https://fangshixiang.blog.csdn.net/article/details/85067006</p>
<h1 id="beanfactory-applicationcontext">BeanFactory ApplicationContext</h1>
<p>BeanFactory：bean工厂<br>
ApplicationContext：可以理解为强化的BeanFactory，提供了BeanFactory的功能外，还提供了MessageSource，事务等功能。</p>
<blockquote>
<p><em>ApplicationContext包含BeanFactory的所有功能，通常建议比BeanFactory优先。</em></p>
<p>ApplicationContext以一种<strong>更向面向框架的方式工作以及对上下文进行分层和实现继承</strong>，ApplicationContext包还提供了以下的功能：</p>
<ul>
<li>MessageSource, 提供国际化的消息访问</li>
<li>资源访问，如URL和文件</li>
<li>事件传播</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专<strong>注于一个特定的层次</strong>，比如应用的web层;</li>
</ul>
</blockquote>
<hr>
<h1 id="factorybean-objectfactory">FactoryBean ObjectFactory</h1>
<p>还是比较有意思的点，但目前没有追踪Spring是如何对这两个类进行处理的，特别的ObjectFactory，是如何处理出Scope这一环境。</p>
<h2 id="factorybean">FactoryBean</h2>
<blockquote>
<p>这是个特殊的 Bean 他是个工厂 Bean，可以产生 Bean 的 Bean</p>
</blockquote>
<p>使用其实也比较简单，将FactoryBean交由Spring管理即可，Spring会根据FactoryBean的属性（单例多例等），创建对应的Bean。</p>
<p>所以可以直接注入FactoryBean对应的Bean。</p>
<h2 id="objectfactory">ObjectFactory</h2>
<p>不同于FactoryBean可以直接通过Spring获取对应的bean，<code>ObjectFactory</code>需要通过Spring注入后，再进行get操作获取bean。</p>
<p>使用情况更多是与与Scope绑定，如<code>WebApplicationContextUtils#registerWebApplicationScopes()</code>中，注入了如Session、Request等ObjectFactory。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glbpmuhy21j30za0j6jwm.jpg" alt="image-20201204122743075" loading="lazy"></figure>
<pre><code class="language-java">	// @Resource ByName注入
	@Resource
	private ObjectFactory&lt;ServletRequest&gt; requestObjectFactory;

	void method(){
    ServletRequest request = requestObjectFactory.getObject();
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring MVC Handler参数封装]]></title>
        <id>https://biubangboom.github.io/post/spring-mvc-handler-can-shu-feng-zhuang/</id>
        <link href="https://biubangboom.github.io/post/spring-mvc-handler-can-shu-feng-zhuang/">
        </link>
        <updated>2020-12-02T05:11:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="入口">入口</h1>
<p>后续（2020年12月03日10:19:06）：整理资料发现对DataBinder，WebDataBinder的认识出现了错误，所以原文中关于DataBinder的介绍许多都是错的，但仍可借此关注SpringMVC入参流程。<br>
DataBinder的源码文章：https://blog.csdn.net/f641385712/article/details/90702928</p>
<p>可以关联PropertyAccessor。DataBinder其实更像是一个组合工具，通过PropertyAccessor封装数据，再通过其他的组件进行validator，实现数据的valid以及property accessor功能。</p>
<blockquote>
<pre><code class="language-java">* Binder that allows for setting property values onto a target object,
* including support for validation and binding result analysis.
* The binding process can be customized through specifying allowed fields,
* required fields, custom editors, etc.
</code></pre>
</blockquote>
<hr>
<p>今早看在mica的xss封装。</p>
<p>发现用到了一个叫<code>InitBinder</code>的注解。发现自己的能力还差很多阿。</p>
<hr>
<p>先记录一下涉及的知识点。</p>
<p><code>ControllerAdvice</code>，<code>PropertyEditor</code>，<code>PropertyEditorSupport</code>，<code>PropertyManager</code>，<code>WebDataBinder</code></p>
<p>比较关心的是通过<code>@InitBinder</code>注册进<code>WebDataBinder</code>的<code>StringPropertiesEditor</code>什么时候会执行。</p>
<p>结论：<code>WebDataBinder</code>其实可以理解为是KV等类型的一个处理流程，通过<code>AbstractNameValueArugmentSolver</code>的<code>ArguemntSolver</code>调用，所以没有脱离ArgumentSolver的范围，并且继承自该抽象类的方法都会调用对应的WebDataBinder。<br>
后记：：<code>AbstractNameValueArugmentSolver</code>为子类预留了<code>handleResolvedValue</code>方法拓展。</p>
<p>简述：其他的argumentSolver(pathVariable,modelAttribute)等其实都extends这个AbstractNameValueMethodArgumentResolver，这个抽象类会调用binder.convertIfNecessary，也就是自定义的initBinder方法。</p>
<p>另外，MVC关于DataBinder的传参等依旧是很复杂（<code>WebDataBinderFactory</code>）的。</p>
<p>WebDataBinder的调用则是通过调用<code>PropertyEditor</code>实现。（PropertyEditorSupport为子类，实现了<code>PropertyEditor</code>接口大部分了方法。）</p>
<pre><code class="language-java">// editor为在WebDataBinder中registCustom的自定义编辑器。
convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);
</code></pre>
<blockquote>
<pre><code class="language-java">// 类信息
public class DataBinder implements PropertyEditorRegistry, TypeConverter
</code></pre>
</blockquote>
<p>之前没有做出过使用。</p>
<p><code>DataBinder</code>通过与ControllerAdvice配合使用。</p>
<blockquote>
<p>关于ControllerAdcice的介绍</p>
<p>Specialization of {@link Component @Component} for classes that declare{@link ExceptionHandler @ExceptionHandler}, {@link InitBinder @InitBinder}, or{@link ModelAttribute @ModelAttribute} methods to be shared across multiple {@code @Controller} classes.</p>
<p>简意：一个Component的特殊类，可用于声明（定义方法）<code>@ExceptionHandler</code>，<code>@InitBinder</code>，@<code>ModelAttribute</code>。<br>
method被多个Controller类共享（Controller全局）。</p>
<p>关于@ModelAttribute还不清楚作用。</p>
</blockquote>
<p><code>ControllerAdvice</code>的<code>InitBinder</code>即是本次的入口。</p>
<blockquote>
<p>关于InitBinder的介绍</p>
<p>Annotation that identifies methods which initialize the {@link org.springframework.web.bind.WebDataBinder} which will be used for populating command and form object arguments of annotated handler methods.</p>
<p>简意：注解会通过<code>WebDataBinder</code>进行初始化。用于填充接口的command和form类型参数。</p>
<p>typical arguments are {@link org.springframework.web.bind.WebDataBinder} in combination with {@link org.springframework.web.context.request.WebRequest} or {@link java.util.Locale}, allowing to register context-specific editors.</p>
<p>简意：@InitBinder注解作用在方法上，方法可传入参数WebDataBinder，WebRequest，Locale辅助使用。<br>
其中<code>WebDataBinder</code>是关键，可用于实现DataBinder的注册。</p>
</blockquote>
<hr>
<h1 id="参数封装流程">参数封装流程</h1>
<p>这是之前为了追踪，如何将请求的参数（form、path variable，requestBody等）封装成对应的类型的属性或对象而进行的追踪，但当时没有完成，也缺少了<code>DataBind</code>这部分的数据处理。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9eq3m6iqj317t044q3e.jpg" alt="image-20200323024355131" loading="lazy"></figure>
<p>在HandlerAdapter.Handle()方法中，对request的param进行成handler所需的对象。（这一行方法其实执行了很多，只是最后得到了model and view罢了，中间蛮多过程且不太好追踪。）</p>
<p>其实基本的入口是没有找错的：<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code></p>
<p><code>InvocableHandlerMethod</code>方法参数封装入口<br>
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9eq569m3j31fh0u0doq.jpg" alt="image-20200323024802095" loading="lazy"></p>
<p>解析逻辑</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9fj3fmmfj31270ebtc2.jpg" alt="image-20201202130632894" loading="lazy"></figure>
<p>获取解析器的逻辑：<code>HandlerMethodArgumentResolverComposite</code><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9eq490mkj31en0o6q99.jpg" alt="image-20200323023101703" loading="lazy"><br>
该类中含有<code>List&lt;HandlerMethodArgumentResolver&gt;</code>，包含了所有的参数解析器。<br>
在方法<code>getArgumentResolver</code>下，对每个参数调用正确的参数解析器进行解析。</p>
<p>其中包括<code>RequestAttributeMethodArgumentResolver</code> <code>RequestParamMethodArgumentResolver</code> <code>RequestParamMapMethodArgumentResolver</code> <code>ServletModelAttributeMethodProcessor</code> <code>RequestResponseBodyMethodProcessor</code><br>
（RequestParam、RequestParamMap、ModelAttributeMethod、RequestBody）</p>
<p>其他的都比较好理解，比较特殊的是**<code>ServletModelAttributeMethodProcessor</code>**，如果不带任何的注解、或是参数类型是简单类型，则会匹配上该方法，可以理解为是默认的。</p>
<pre><code class="language-java">@Override
	public boolean supportsParameter(MethodParameter parameter) {
		return (parameter.hasParameterAnnotation(ModelAttribute.class) ||
				(this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));
	}
</code></pre>
<p>同理，如果对象不带任何的注解=@ModelAttribute。（不同于@RequestAttribute）。</p>
<p>同时发现可以使用<code>Map&lt;String,String&gt;</code>可以封装上所有的RequestParam，默认实现了。</p>
<h1 id="总结">总结</h1>
<p>竟然误解了。</p>
<p>一直想追踪这个DataBinder与ArgumentResolver的执行顺序。</p>
<p>但其实不是这样的。</p>
<p>DataBinder的执行是在一个抽象类：<code>AbstractNamedValueMethodArgumentResolver</code>中，是其他的ArgumentResolver（kv类型等）的抽象类。</p>
<blockquote>
<p>抽象类的介绍：</p>
<p>Abstract base class for resolving method arguments from a named value. Request parameters, request headers, and path variables are examples of named values. Each may have a name, a required flag, and a default value.</p>
<p>简介：</p>
<p>这个抽象类可以帮助方法解决一些kv类型的请求参数、请求头信息或者路径变量。</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9f7snlovj311d0djn1r.jpg" alt="image-20201202125610629" loading="lazy"></figure>
<p>由该抽象类定义的方法（resolveArgument）实现对DataBinder的调用，同时预留<code>handleResolvedValue</code>方法交由实现类拓展。</p>
<hr>
<p>似乎也不是如此，MVC的参数封装似乎都是通过ServletRequestDataBinder的对象进行实现，这个ServletRequestDataBinder extends WebDataBinder。</p>
<h1 id="参数封装补充细节">参数封装补充细节</h1>
<p>Handler参数的封装都是通过ArguementSolver进行处理，而ArgumentSolver内部封装了DataBinder，本质上就是调用DataBinder进行参数的封装。</p>
<p><code>attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</code></p>
<p>普遍的DataBinder内部是通过 <code>getTypeConverter().convertIfNecessary(value, requiredType, methodParam);</code>进行convert，而这个<code>TypeConverter</code>--&gt;SimpleTypeConverter。也就是调用<code>TypeConverterSupport</code>的<code>convertIfNecessary</code>方法进行转换。</p>
<p><code>getTypeConverter().convertIfNecessary(value, requiredType, methodParam);</code></p>
<p>大多数情况这个TypeConverter，其实就是<code>SimpleTypeConverter</code>，通过这个TypeConverter根据不同的情况调用PropertyEditor或者ConverterService进行转换。</p>
<pre><code class="language-java">	/**
	 * 这个SimpleTypeConverter其实就是已经封装了convertService进去，可供使用。
	 * Return this binder's underlying SimpleTypeConverter.
	 */
	protected SimpleTypeConverter getSimpleTypeConverter() {
		if (this.typeConverter == null) {
			this.typeConverter = new SimpleTypeConverter();
			if (this.conversionService != null) {
				this.typeConverter.setConversionService(this.conversionService);
			}
		}
		return this.typeConverter;
	}

public class SimpleTypeConverter extends TypeConverterSupport {

	public SimpleTypeConverter() {
		this.typeConverterDelegate = new TypeConverterDelegate(this);
		registerDefaultEditors();
	}

}
</code></pre>
<pre><code class="language-java">MethodArugementResolve-&gt;resolveArgument-&gt;
// 竟然是在这里处理的@initBinder
// 而且处理流程也比较魔幻..
WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name); 
attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
</code></pre>
<p>每个参数的封装都会对应创建<code>ServletRequestDataBinder</code>，而这个<code>ServletRequestDataBinder</code>的init会通过Spring MVC中的WebDataBinder，<strong>是通过这个ServletRequestDataBinder对Handler的各参数进行独自封装。</strong></p>
<pre><code class="language-java">	// DefaultDataBinderFactory中调用。
	// 方法参数的`args[i]`的封装是通过这个`ServletRequestDataBinder`实现。
	@Override
	@SuppressWarnings(&quot;deprecation&quot;)
	public final WebDataBinder createBinder(
			NativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {
		// args[i] solver对应的dataBinder，ServletRequestDataBinder
		WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);
		if (this.initializer != null) {
			this.initializer.initBinder(dataBinder, webRequest);
		}
    // 这里竟然也是个关键，对应了@initMethod的处理
		initBinder(dataBinder, webRequest); //ServletRequestDataBinderFactory
		return dataBinder;
	}
</code></pre>
<pre><code class="language-java">	// this.initializer.initBinder(dataBinder, webRequest);
	// ServletRequestDataBinder的INIT过程之一
	// 传入的binder其实就是MVC容器的WebDataBinder
	@Override
	public void initBinder(WebDataBinder binder) {
		binder.setAutoGrowNestedPaths(this.autoGrowNestedPaths);
		if (this.directFieldAccess) {
			binder.initDirectFieldAccess();
		}
		if (this.messageCodesResolver != null) {
			binder.setMessageCodesResolver(this.messageCodesResolver);
		}
		if (this.bindingErrorProcessor != null) {
			binder.setBindingErrorProcessor(this.bindingErrorProcessor);
		}
		if (this.validator != null &amp;&amp; binder.getTarget() != null &amp;&amp;
				this.validator.supports(binder.getTarget().getClass())) {
			binder.setValidator(this.validator);
		}
		if (this.conversionService != null) {
			binder.setConversionService(this.conversionService);
		}
		if (this.propertyEditorRegistrars != null) {
			for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {
				propertyEditorRegistrar.registerCustomEditors(binder);
			}
		}
	}
</code></pre>
<pre><code class="language-java">	// 也是比较关键的一个方法，在InitBinderDataBinderFactory中执行。
	/**
	 * Initialize a WebDataBinder with {@code @InitBinder} methods.
	 * &lt;p&gt;If the {@code @InitBinder} annotation specifies attributes names,
	 * it is invoked only if the names include the target object name.
	 * @throws Exception if one of the invoked @{@link InitBinder} methods fails
	 * @see #isBinderMethodApplicable
	 */
	@Override
	public void initBinder(WebDataBinder dataBinder, NativeWebRequest request) throws Exception {
		// 获取被@InitMethod的方法
    for (InvocableHandlerMethod binderMethod : this.binderMethods) {
			if (isBinderMethodApplicable(binderMethod, dataBinder)) {
        // 反射执行这些@InitMethod方法，也就是往这个RequestDataBinder中注册PropertyEditor(XSS)
        // 这里执行其实比较魔幻，粗略可以理解成是把这个binderMethod方法当成普通的方法执行，所以也会有对这个普通方法进行argument resolve的过程（类似于处理handler）。
				Object returnValue = binderMethod.invokeForRequest(request, null, dataBinder);
				if (returnValue != null) {
					throw new IllegalStateException(
							&quot;@InitBinder methods must not return a value (should be void): &quot; + binderMethod);
				}
			}
		}
	}
</code></pre>
<pre><code class="language-java">	/**
	 * Invoke the method after resolving its argument values in the context of the given request.
	 * &lt;p&gt;Argument values are commonly resolved through
	 * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.
	 * The {@code providedArgs} parameter however may supply argument values to be used directly,
	 * i.e. without argument resolution. Examples of provided argument values include a
	 * {@link WebDataBinder}, a {@link SessionStatus}, or a thrown exception instance.
	 * Provided argument values are checked before argument resolvers.
	 * &lt;p&gt;Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the
	 * resolved arguments.
	 * @param request the current request
	 * @param mavContainer the ModelAndViewContainer for this request
	 * @param providedArgs &quot;given&quot; arguments matched by type, not resolved
	 * @return the raw value returned by the invoked method
	 * @throws Exception raised if no suitable argument resolver can be found,
	 * or if the method raised an exception
	 * @see #getMethodArgumentValues
	 * @see #doInvoke
	 */
	@Nullable
	public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception {
		
		Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));
		}
		return doInvoke(args);
	}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glc5yd6yhoj317c0u0kf3.jpg" alt="image-20201204215153059" loading="lazy"></figure>
<h1 id="资料">资料</h1>
<p>https://blog.csdn.net/f641385712/article/details/90702928</p>
<p>补充关于mica xss-common的设置（文章入口来源）：</p>
<pre><code class="language-java">@ControllerAdvice
public class FormXssClean {

	@InitBinder
	public void initBinder(WebDataBinder binder) {
		// 处理前端传来的表单字符串
		binder.registerCustomEditor(String.class, new StringPropertiesEditor());
	}

	@Slf4j
	public static class StringPropertiesEditor extends PropertyEditorSupport {

		@Override
		public String getAsText() {
			Object value = getValue();
			return value != null ? value.toString() : StrUtil.EMPTY;
		}

		@Override
		public void setAsText(String text) throws IllegalArgumentException {
			if (text == null) {
				setValue(null);
			}
			else if (XssHolder.isEnabled()) {
				String value = XssUtil.clean(text);
				setValue(value);
				log.trace(&quot;Request parameter value:{} cleaned up by mica-xss, current value is:{}.&quot;, text, value);
			}
			else {
				setValue(text);
			}
		}

	}
}
</code></pre>
<h1 id="databinder">DataBinder</h1>
<p>资料：https://blog.csdn.net/shenchaohao12321/article/details/80356890</p>
<p>资料：https://blog.csdn.net/f641385712/article/details/90702928</p>
<blockquote>
<p>DataBinder实现了TypeConverter和PropertyEditorRegistry接口提供了类型转换功能，并且可以对目标对象字段做<a href="https://blog.csdn.net/shenchaohao12321/article/details/100163991">Validation</a>。</p>
</blockquote>
<pre><code class="language-java">	@Test
	public void run() throws BindException {
		Film film = new Film();
		DataBinder dataBinder = new DataBinder(film,&quot;film&quot;);

		MutablePropertyValues pvs = new MutablePropertyValues();
		pvs.add(&quot;id&quot;, 1);
		pvs.add(&quot;film&quot;, &quot;inception&quot;);

		dataBinder.bind(pvs);
		dataBinder.close();

    // Film{id=1, film='inception'}
		System.out.println(film);
	}
</code></pre>
<hr>
<h1 id="spring-mvc的默认conversionservice来源">Spring MVC的默认ConversionService来源</h1>
<pre><code class="language-java">@Configuration
class WebMvcConfigurationSupport{
	/**
	 * Return a {@link FormattingConversionService} for use with annotated controllers.
	 * &lt;p&gt;See {@link #addFormatters} as an alternative to overriding this method.
	 */
	@Bean
	public FormattingConversionService mvcConversionService() {
		FormattingConversionService conversionService = new DefaultFormattingConversionService();
		addFormatters(conversionService);
		return conversionService;
	}
}
</code></pre>
<p>追踪了好一会儿。</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glbszbyljlj31pj0u0tn5.jpg" alt="image-20201204142332815" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatis-IOC追踪]]></title>
        <id>https://biubangboom.github.io/post/mybatis-ioc-zhui-zong/</id>
        <link href="https://biubangboom.github.io/post/mybatis-ioc-zhui-zong/">
        </link>
        <updated>2020-11-18T15:52:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="官方文档入口">官方文档入口</h1>
<p>Spring-Mybatis：https://mybatis.org/spring/zh/getting-started.html</p>
<h1 id="基于注解与ioc实现mybatis的源码分析">基于注解与IOC实现Mybatis的源码分析</h1>
<h2 id="基于注解启动spring-mybatis流程追踪">基于注解启动Spring-Mybatis流程追踪</h2>
<h3 id="mapperscanners作为入口">@MapperScanners作为入口</h3>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkt5vd5kwej30op07njsa.jpg" alt="image-20201118112342843" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkt5voezjqj30wb02gt8x.jpg" alt="image-20201118112405695" loading="lazy"></figure>
<hr>
<p>对于每个MapperScanner执行<code>void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry)</code>方法。</p>
<pre><code class="language-java">ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkt6929n16j30j10mkq58.jpg" alt="image-20201118113657384" loading="lazy"></figure>
<pre><code class="language-java">// annotations是MapperScanners注解类。
for (int i = 0; i &lt; annotations.length; i++) {
  registerBeanDefinitions(importingClassMetadata, annotations[i], registry,
      generateBaseBeanName(importingClassMetadata, i));
}
</code></pre>
<pre><code class="language-java">// foreach执行`registerBeanDefinitions`方法
// registerBeanDefinitions抽离
BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
// **MapperScannerConfigurer**
// 读取MapperScanner中的annoMeta(注解信息)封装进builder（MapperScannerConfigurer BeanDefinitionBuilder）中。

传入的信息也比较关键，这个MapperScannerConfigurer类似于@Mapper扫包配置类，所以里面包括了说需要扫描@Mapper注解，需要扫描的路径basePackage等信息。
</code></pre>
<p>（AutoConfiguredMapperScannerRegistrar中自动配置的MapperScannerConfigurer情况）</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkte72i8zrj311l0dn789.jpg" alt="image-20201118161150003" loading="lazy"></figure>
<p>这个MapperScannerConfigurer是个<strong>BeanDefinitionRegistryPostProcessor</strong>类 ----&gt; <code>postProcessBeanDefinitionRegistry()</code></p>
<pre><code class="language-java">public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
		// 应该就是扫包器了，扫描@MapperScan(basePage=“”),extends ClassPathBeanDefinitionScanner..
		ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
 		scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage,ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));   
}
</code></pre>
<pre><code class="language-java">public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner
</code></pre>
<p>启动@Mapper扫描</p>
<figure data-type="image" tabindex="5"><img src="../../Library/Application%20Support/typora-user-images/image-20201118161515175.png" alt="image-20201118161515175" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gktekfrlrzj311n0e6ad0.jpg" alt="image-20201118162431588" loading="lazy"></figure>
<p>这个就是关键的实现@Mapper自动注入功能的流程了。</p>
<figure data-type="image" tabindex="7"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gktep5381oj30we0u0qf2.jpg" alt="image-20201118162911933" loading="lazy"></figure>
<pre><code class="language-java">      // the mapper interface is the original class of the bean.but, the actual class of the bean is MapperFactoryBean
      // 设置(MapperBeanFactory)构造器的参数
      definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59
			// 关键内容设置 ---&gt; MapperFactoryBean.class
      definition.setBeanClass(this.mapperFactoryBeanClass);

			// 设置sqlSessionFactory
			
			// 设置sqlTemplateFactory

			// definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
</code></pre>
<p>所以上述是流程的追踪，下面是动态代理类（MapperFactoryBean）如何实现动态代理。</p>
<h2 id="功能实现的核心">功能实现的核心</h2>
<h3 id="mapperfactorybean"><strong>MapperFactoryBean</strong></h3>
<pre><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt;
</code></pre>
<pre><code class="language-java">// SqlSessionDaoSupport &lt;-- DaoSupport 中抽象出来的方法。
// 与SpringJDBC应该有不少的关系，需要继续学习这部分。
protected void checkDaoConfig(){
 Configuration configuration = getSqlSession().getConfiguration();
 // 但这里解决了一个困惑点。
 // 正常Mybatis的DefaultSessionFactory获取Mapper对象，其实都是通过configuration获取，流程看下代码框。
 configuration.addMapper(this.mapperInterface);
}

---
 // Configuration
   public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
   mapperRegistry.addMapper(type);
 }
</code></pre>
<pre><code class="language-java">	@Override
  public T getObject() throws Exception { // FactoryBean的方法。
    // getSqlSession()--&gt;DefaultSqlSession
    // this.mapperInterfact，接口类。
    return getSqlSession().getMapper(this.mapperInterface);
  }

	---
    // DefaultSqlSession
    @Override
  	public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
    	// 会通过配置文件获取，与原版Mybatis逻辑相同。
    	// 这里的原因其实有在「checkDaoConfig」中，通过addMapper加载进Configuration。
    	return configuration.getMapper(type, this);
	  }
  
</code></pre>
<pre><code class="language-java">	// MapperRegistrar 动态代理实现了就是。
	@SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
    }
    try {
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
    }
  }
</code></pre>
<hr>
<h1 id="基于spring-bootmybatis-spring-boot-starter的自动装配流程">基于Spring Boot(mybatis-spring-boot-starter)的自动装配流程</h1>
<pre><code class="language-xml">				&lt;!--spring framework version :: 2.4.0--&gt;
				&lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.4&lt;/version&gt;
        &lt;/dependency&gt;
-----------
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
  &lt;/dependencies&gt;
</code></pre>
<p>这边解析一下新增加的<code>mybatis-spring-boot-autoconfigure</code></p>
<pre><code class="language-properties"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
</code></pre>
<p><code>MybatisAutoConfiguration</code></p>
<pre><code class="language-java">/**
 * {@link EnableAutoConfiguration Auto-Configuration} for Mybatis. Contributes a {@link SqlSessionFactory} and a
 * {@link SqlSessionTemplate}.
 *
 * If {@link org.mybatis.spring.annotation.MapperScan} is used, or a configuration file is specified as a property,
 * those will be considered, otherwise this auto-configuration will attempt to register mappers based on the interface
 * definitions in or under the root auto-configuration package.
 *
 * @author Eddú Meléndez
 * @author Josh Long
 * @author Kazuki Shimizu
 * @author Eduardo Macarrón
 */


// 简化：为应用程序构造SqlSessionFactory，SqlTemplate。
// 如果有使用MapperScan注册则注解将会起作用。
// otherwise,这个autoCOnfiguration会尝试去注册在root auto-configuration package下的基于接口定义。 ？？？
</code></pre>
<pre><code class="language-java">@org.springframework.context.annotation.Configuration
@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })
@ConditionalOnSingleCandidate(DataSource.class)
@EnableConfigurationProperties(MybatisProperties.class)
@AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })
</code></pre>
<p><code>MybatisAutoConfiguration</code>构造器</p>
<pre><code class="language-java">MybatisProperties
interceptorsProvider
typeHandlersProvider
languageDriversProvider
resourceLoader
databaseIdProvider
configurationCustomizersProvider
  
# MybatisProperties 读取配置文件（application.properties）后封装的对象数据
这个配置文件还挺多内容选项的。包括传统的xml配置文件路径，mapperLocation，typeAliasesPackage，typeAliasesSuperType等等，可理解为传统的mybatis configuration配置文件转移到了spring boot配置文件中。
  
  
# interceptorsProvider 这个蛮重要的，对于Mybatis的拓展。目前不太明白是如何填装进去的。
  
----其余的先先省略。继续追踪启动流程。
</code></pre>
<p>之后的MybatisAutoConfiguration流程就简单很多的，检查是否有配置配置文件（xml等），如果有并且（check）则进行加载。</p>
<p>接着就就是填装SqlSessionFactoryBean SqlTemplate。</p>
<p><strong>同时这个MybatisAutoConfiguration类中，竟然有内部类..</strong></p>
<p><code>MapperScannerRegistrarNotFoundConfiguration</code></p>
<pre><code class="language-java">/**
   * If mapper registering configuration or mapper scanning configuration not present, this configuration allow to scan
   * mappers based on the same component-scanning path as Spring Boot itself.
   */
  @org.springframework.context.annotation.Configuration
  @Import(AutoConfiguredMapperScannerRegistrar.class)
  @ConditionalOnMissingBean({ MapperFactoryBean.class, MapperScannerConfigurer.class })
public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean 
</code></pre>
<p>Import的这个<code>AutoConfiguredMapperScannerRegistrar</code>这个就比较关键了。</p>
<p>用于注册<code>MapperScannerConfigurer</code>进BeanFactory。</p>
<figure data-type="image" tabindex="8"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gktdtbswgoj312z0n8gs7.jpg" alt="image-20201118155835237" loading="lazy"></figure>
<p>这就回到了Spring-Mybatis中（基于MapperScannerConfigurer实现）。</p>
<p><strong>总结：所以这个Mybatis starter关键有三步。</strong></p>
<ol>
<li>
<p>读取application-properotes（MybatisProperties类），将过往的基于xml的配置文件生成Configuration方式替换掉。</p>
<p>这一步骤通过注解与构造器实现，完成后还会对配置文件中的数据进行一个校验（<code>afterPropertiesSet</code>），例如配置了configurationLocation等。</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)
// 这里就已经包含了Mybatis的Configuration类，没错，就是Mybatis中的那个比较关键的类。
public class MybatisProperties 

//但在基于SpringBoot或是注解的情况下，这个原本挺重要的Configuration类似乎又不那么重要，甚至只在特殊的情况下，例如custom 		config的情况下发挥作用。
  
  /**
   * A Configuration object for customize default settings. If {@link #configLocation} is specified, this 		 * property is
   * not used.
   */

  
</code></pre>
</li>
<li>
<p>基于@Bean注解，生成SqlSessionFactory，SqlTemplate。</p>
<pre><code class="language-java">@Bean
@ConditionalOnMissingBean
public void method(){}
</code></pre>
</li>
<li>
<p>引入<code>AutoConfiguredMapperScannerRegistrar</code>类，引入方式其实与@Bean相同，只不过通过了内部类实现。</p>
<pre><code class="language-java">@org.springframework.context.annotation.Configuration
@Import(AutoConfiguredMapperScannerRegistrar.class)
@ConditionalOnMissingBean({ MapperFactoryBean.class, MapperScannerConfigurer.class }
public static class MapperScannerRegistrarNotFoundConfiguration{}
</code></pre>
</li>
<li>
<p>Import并执行<code>AutoConfiguredMapperScannerRegistrar</code>类，通过MybatisProperties信息，构造<code>MapperScanConfigurer</code>，并放入BeanFactory。</p>
</li>
</ol>
<p>往下的流程就是执行<code>MapperScanConfigurer</code>的过程。这过程与Spring-Mybatis一致，意思是至此，mybatis-spring-boot-starter的工作基本实现。</p>
<hr>
<h1 id="容易混淆的记录点">容易混淆的记录点</h1>
<ul>
<li>Import</li>
<li>ImportSelector</li>
<li>Configuration</li>
<li>ImportBeanDefinitionRegistrar</li>
<li>BeanDefinitionPostProcessor</li>
</ul>
<p><code>MapperScannerConfigurer</code>??</p>
]]></content>
    </entry>
</feed>